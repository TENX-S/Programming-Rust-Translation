# 浮点类型
Rust提供IEEE中的单双精度的浮点数，并遵循IEEE 754-2008规范，这些类型包含正负无穷，不同的正零和负零值以及一个非数字值：
![](../../img/img-book/ch3-08.png)

Rust的`f32`和`f64`对应于支持IEEE浮点的C/C++实现的float和double类型，并且也对应于习惯使用IEEE浮点的Java。

浮点字面量的一般形式如下图所示：
![](../../img/img-book/ch3-09.png)
整数部分后面的三个部分都是可选的，但至少要出现一个以区别于整数字面量，小数部分(fractional part)可能包含一个单独的小数点，所以 `5.`是一个合法的常数。

如果一个浮点数没有类型后缀，Rust会从上下文中推断它是`f32`还是`f64`，如果都有可能，则默认为`f64`。（类似的，C/C++和Java都把无后缀的浮点字面里看成是`double`值。）为了类型推断，Rust将整数字面量和浮点字面量视为不同的类：即永远不会将一个整数字面量推断为浮点类型，反之亦然。
下面是一些浮点字面量的例子：
![](../../img/img-book/ch3-10.png)

标准库的`std::f32`和`std::f64`模块定义里IEEE要求的特殊值像`INFINITY,`，`NEG_INFINITY`（负无穷），`NAN`（非数字，not a number），还有`MIN`和`MAX`（最大和最小的有限值）。`std::f32`和`std::f64`模块提供了多种常见的数学常量像`E`,`PI`和根号2。

`f32`和`f64`类型题哦那个了完整的数学计算方法；例如，`2f64.sqrt()`是双精度的根号2。标准库文档使用"`f32` (primitive type)"和“`f64` (primitive type)”来描述它们：
下面是一些例子：
```rust
    assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.);
    assert_eq!(-1.01f64.floor(), -1.0);
    assert!((-1. / std::f32::INFINITY).is_sign_negative());

```
正如之前所述，通常在实际代码中，你不需要写这些类型后缀因为上文会决定这些类型。然而，如果不是这样，由此引发的错误信息会令人惊讶。举例，下面这行代码无法通过编译：
```rust
    println!("{}", (2.0).sqrt());

```
Rust提出:
            <pre>error: no method named sqrt found for type \`{float}\` in the current scope</pre>
这令人意想不到；除了浮点类型，还有哪里能找到`sqrt`方法呢？解决的办法是用一种或另一种方式声明你想要的类型：
```rust
    println!("{}", (2.0_f64).sqrt());
    println!("{}", f64::sqrt(2.0));

```
不同于C/C++，Rust几乎没有隐式类型转换。如果一个函数需要一个`f64`的参数，则传递`i32`的值作为其参数是错误的。事实上，即时每个`i16`的值都是`i32`的值，Rust也不会将`i16`的值隐式转换为`i32`的值。但是这里的关键词是*隐含的*：你始终可以使用`as`运算符写出明确的转换：`i as f64`或者`x as i32`。缺少隐式转换会使得Rust的表达式相较于类似的C/C++代码更冗长。然而，有一份完善的记录表明，隐式整数转换会引起错误和安全漏洞；根据我们的经验，在Rust中写出数字转换使我们警惕了本来会错过的问题。我们会在第六章：表达式中类型转换这一节解释转换的细节。