# 整数类型
Rust的无符号整数类型全部用来表示正值和零：


![](../../img/img-book/ch3-04.png)

Rust的带符号整数类型使用两者的补码表示形式，并使用与相应的无符号类型相同的位模式来覆盖正值和负值的范围：


![](../../img/img-book/ch3-05.png)

Rust通常将u8类型用于字节值。例如，从文件或套接字读取数据将产生u8值流。
不同于C/C++，Rust将字符类型区别与数字类型；一个`char`既不是`u8`也不是`i8`，我们将稍后讲到`char`类型。

`usize`和`isize`类型类似与C/C++中的`size_t`和`ptrdiff_t`，`usize`类型是无符号的而`isize`类型是带符号的。它们的精确度依赖于目标机器地址空间的大小：它们在32位架构上是32位长的，在64位架构上是64位长的。Rust规定数组索引是`usize`的。表示数组或向量的大小或者某种数据结构所含元素的数量的值一般都用`usize`类型。
在调试环境下，Rust会检测算数溢出：
```rust
    let big_val = std::i32::MAX;
    let x = big_val + 1;

```

在发型版本中，这个加法的结果会变成一个负数（不同于C++，带符号整数溢出是未定义的行为）。但是除非你想永远放弃调试，依靠于这样的行为不是一个好主意。当你想到得到溢出算术结果时，用这个方法：
```rust
    let x = big_val.wrapping_add(1);

```

Rust中的整数字面量可以用一个后缀来指示其类型：`42u8`是一个`u8`，`1729isize`是一个`isize`。你可以忽略一个整数字面量的后缀，那样的话Rust会尝试从上下文中推导出它的类型。这个推导通常会定义一个特别的类型，但有时几个类型中任意一个都有效。在这种情况下，如果`i32`类型在那几个可能性中，Rust会默认选择它。否则，Rust会将这种模棱两可的情况视为一个错误并报出。

前缀`0x`，`0o`和`0b`表示十六进制，八进制和二进制。

为了使长整数更具可读性，你可以在数字中插入下划线。比如，你可以这样写最大的`u32`整数的值：`4_294_967_295`。下划线具体放在哪里无关紧要，所以你可以在十六进制或二进制中每隔四个而不是三个来放置下划线，比如`0xffff_ffff`或者将类型后缀与数字分离`127_u8`。

下面是一些整数字面量的例子：


![](../../img/img-book/ch3-06.png)

尽管数字类型和`char`类型是分开的，Rust却提供了字节字面量(byte literals)，字面量的字符类似于`u8`的值：`b'X'`表示作为一个字符`X`的ASCII码（u8值）。例如：我们都知道字符`'A'`的ASCII码是65，字面量`b'A'`和`65u8`是完全等价的。字节字面量中只会出现ASCII字符。

下面几个字符你不能仅仅使用单引号来表示，因为那会使得句法上模棱两可或者难以阅读。所以需要一个反斜线放在它们前面。


![](../../img/img-book/ch3-07.png)

如果一些字符难以读写，你可以使用它们的十六进制码来代替。一个形如`b'\xHH'`的字节字面量，HH是任意两个十六进制数，代表了值为HH的字节。例如，因为‘escape’控制字符的ASCII码为27或者十六进制下的`1B`，你可以将其写为`b'\x1b'`的字节字面量。因为字节字面量仅仅只是`u8`值的另一种表示，所以当考虑一个简单的数字字面量是否更易读：即当你只想强调一个值代表ASCII码时，可能用`b'\x1b'`相比于仅用27更符合情理。

你可以使用`as`算子对整数进行类型转换，我们将在第六章：表达式中类型转换这一节解释转换的细节，但先看下面几个例子吧：
```rust
    assert_eq!(    10_i8 as u16, 10_u16);
    assert_eq!( 2525_u16 as i16, 2525_i16);

    assert_eq!(   -1_i16 as i32, -1_i32);
    assert_eq!(65535_u16 as i32, 65535_i32);
    // 超出目标范围的转换所产生的值为原始值模2^N
    // 其中N是目标的宽度（以位为单位）
    // 这有时被称为截断。
    assert_eq!( 1000_i16 as u8, 232_u8);
    //  1000 mod 2^8 = 232
    assert_eq!(65535_u32 as i16, -1_i16);
    //65535 mod 2^16 = -1

    assert_eq!(     -1i8 as u8, 255_u8);
    //    -1 mod 2^8 = 255
    assert_eq!(   255_u8 as i8, -1_i8);
    //   255 mod 256 = -1

```

类似于任何其他类型的值，整数也有方法。标准库提供了一些基本的操作，你可以从在线文档中进行查阅。注意到那个文档包含类型本身的单独页面（例如，搜索"`i32` (primitive type)"）,对于该类型的模块（搜索“`std::i32`”）。例如：
```rust
    assert_eq!(2u16.pow(4), 16);           // 求幂
    assert_eq!((-4i32).abs(), 4);          // 绝对值
    assert_eq!(0b101101u8.count_ones(), 4);// 数量

```

这里的字面量的类型后缀是必需的：Rust如果不知道值的类型就不能寻找它的方法。在真实的代码中，然而，通常会有其他上下文来消除类型的歧义，因此后缀是非必需的。

